### QA Report for [Optimism-SuperChain](https://github.com/code-423n4/2024-07-optimism) by K42

- I made sure these do not overlap with already covered issues. 

### Low Severity Issues

| Issue ID | Description                                                                                                                                                                                                                                                                                                                  | Location Link                                                                                                                       | Impact                                                                                                                                                       | Recommended Mitigation Steps                                                                                                                            |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| QA-01    | `resolveClaim` function may run out of gas for large subgames                                                                                                                                                                                                                                                                | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L560)   | The function may fail due to exceeding the block gas limit, preventing resolution of large dispute games.                                                    | Implement a pagination mechanism to resolve claims in manageable chunks.                                                                                |
| QA-02    | `getChallengerDuration` may return incorrect duration for games not in progress                                                                                                                                                                                                                                              | [Link]( https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L767)  | Prevents querying the final challenger duration for completed games, useful for analysis or other audits.                                                        | Modify the function to return the final duration even if the game is not in progress by storing the final game timestamp when the game concludes.       |
| QA-03    | `challengeRootL2Block` function does not verify the integrity of `_outputRootProof`                                                                                                                                                                                                                                          | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L492)   | Malformed or inconsistent data in `_outputRootProof` may produce a valid hash, leading to incorrect challenge outcomes.               | Add additional checks to validate the integrity of `_outputRootProof` fields.                                                                           |
| QA-04    | Potential overflow in `getChallengerDuration` function                                                                                                                                                                                                                                                                       | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L767)   | In extreme cases, the addition could overflow if the sum exceeds `type(uint64).max`, leading to incorrect duration calculation.                              | Perform overflow check before addition.                                                                          |
| QA-05    | `resolveClaim` function lacks check for zero `_numToResolve`                                                                                                                                                                                                                                                                 | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L560)   | Function may execute without resolving any claims if `_numToResolve` is zero, wasting gas and allowing pointless function calls.                           | Add a check to revert if `_numToResolve` is `0`.                                                                                                       |
| QA-06    | `challengeRootL2Block` function doesn't validate `_headerRLP` length                                                                                                                                                                                                                                                         | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L492)   | Malformed or too short RLP data could potentially lead to incorrect game state or pointless reverts.                                     | Add a check to ensure `_headerRLP` has a minimum expected length before processing.                                                                     |
| QA-07    | `claimCredit` function doesn't check if `_recipient` is a contract                                                                                                                                                                                                                                                           | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L747)   | Funds could be permanently locked if the recipient is a contract without proper ETH receiving capabilities.                                                  | Add a check to ensure the recipient is not a contract, or handle the case where it might be.                                                            |
| QA-08    | `gameImpls` mapping allows setting implementation to `address(0)`                                                                                                                                                                                                                                                              | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L199) | Setting an implementation to `address(0)` could lead to reverts when trying to create new games of that type.                           | Add a check to prevent setting the implementation to the `address(0)`.                                                                                  |
| QA-09    | Potential for creating duplicate games with different `extraData`                                                                                                                                                                                                                                                              | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L84)  | Multiple games could exist for the same root claim, differentiated only by their extra data, leading to confusion and potential exploitation.                | Use only `_gameType` and `_rootClaim` to determine uniqueness, add additional checks to prevent creating multiple games for the same root claim.     |
| QA-10    | Lack of bounds checking in `SE` function                                                                                                                                                                                                                                                                                     | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/MIPS.sol#L75)                 | Incorrect sign extension could occur if the function is called with invalid parameters, leading to misinterpretation of data in the MIPS emulation.          | Add a bounds check to ensure `_idx` is within a valid range `(1 to 32)`.                                                                                  |
| QA-11    | Potential for overflow in `handleHiLo` function for `mult` and `multu` operations                                                                                                                                                                                                                                                | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/MIPS.sol#L383)                | In edge cases involving very large numbers, the multiplication result might be truncated, leading to incorrect values stored in the `hi` and `lo` registers. | Use a `128-bit` data type or a library that supports `128-bit` arithmetic to ensure full precision for all possible MIPS multiplication results. |
| QA-12    | Stale data in `loadBlobPreimagePart`                                                                                                                                                                                                                                                                           | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageOracle.sol#L244)      | There's no way to determine when a specific blob preimage part was added or if  most recent version, leading to stale data issues.         | Add a timestamp or block number when storing blob preimage parts.                                                                           |
| QA-13    | Lack of cleanup mechanism for obsolete/dead proposals                                                                                                                                                                                                                                                                             | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageOracle.sol)           | Over time, this could lead to accumulated storage bloat, increasing gas costs for operations that interact with the proposal data structures.                | Implement a cleanup mechanism for proposals that have been finalized or have remained inactive for a long period, to prevent this.                           |
| QA-14     | Memory management in `keccak256PreimageKey`: The function doesn't explicitly clean up the memory it uses. While EVM will handle this automatically, in complex scenarios involving a lot of memory usage, this could eventually lead to higher gas costs, so best to mitigate now.                                                          | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageKeyLib.sol#L47)                                                                                                                        | Higher gas costs in complex scenarios due to memory bloat.                                                                                         | Explicitly zero out the memory used for `_preimage` after computing the hash. This helps ensure no residual data remains in memory, best to clean up.                     |
| QA-15    | Potential read-after-write hazard in `localize`: In the assembly block of `localize`, the free memory pointer is read, used, and then restored. If another operation were to modify memory between these operations (unlikely in this context, but still possible, therefore can be mitigated), as it could potentially lead to issues. | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageKeyLib.sol#L29)                                                                                                                        | Memory corruption if memory is modified between the operations.                                                                                    | Use a more secure method to handle memory operations, ensuring no unintended modifications occur.                                                       |
| QA-16    | Lack of zero-length input handling in `keccak256PreimageKey`: If an empty byte array is passed to this function, it will still compute a key.                                                                 | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageKeyLib.sol#L47)                                                                                                                        | Unexpected vulnerabilities if empty byte arrays are not intended to be handled.                                               | Add a check to handle zero-length inputs appropriately, either by reverting or by returning a specific value.                                           |
| QA-17    | Wrong data type for `partOffset` function return type: `partOffset` should return `uint32` instead of `uint64` for continuity with `setPartOffset`.                                                                                                                                                                  | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L66)                                                                                                                        | Confusion in data handling.                                                                                                  | Change the return type of `partOffset` to `uint32`.                                                                                                     |
| QA-18    | Data truncation in `setCountered` function: The `setCountered` function may cause data truncation if `_countered` is set to `true`, affecting other metadata fields.                                                                                                                                                 | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L54)                                                                                                                        | Potential corruption of metadata fields.                                                                                                                     | Ensure `_countered` only affects the intended bit and does not alter other metadata fields.                                                             |
| QA-19    | Lack of bounds checking in `set` functions: The `set` functions do not check the bounds of their inputs, this could lead to incorrect metadata values.                                                                                                                                                                   | [Link](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L24C1-L58C6)                                                                                                                        | Incorrect metadata values due to lack of input validation.                                                                                                   | Add bounds checking for inputs in `set` functions to ensure they are within accurate ranges.                                                            |

### Detailed Breakdown of All Low Severity Issues:

### **FaultDisputeGame**

### QA-01 `resolveClaim` function may run out of gas for large subgames

### Proof of Concept

- Location = [resolveClaim()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L560) function:

```solidity
function resolveClaim(uint256 _claimIndex, uint256 _numToResolve) external {
    // ... [code omitted for brevity]

    uint256[] storage challengeIndices = subgames[_claimIndex];
    uint

256 challengeIndicesLen = challengeIndices.length;

    // ... [code omitted for brevity]

    uint256 lastToResolve = checkpoint.subgameIndex + _numToResolve;
    uint256 finalCursor = lastToResolve > challengeIndicesLen ? challengeIndicesLen : lastToResolve;
    for (uint256 i = checkpoint.subgameIndex; i < finalCursor; i++) {
        uint256 challengeIndex = challengeIndices[i];

        // INVARIANT: Cannot resolve a subgame containing an unresolved claim
        if (!resolvedSubgames[challengeIndex]) revert OutOfOrderResolution();

        ClaimData storage claim = claimData[challengeIndex];

        // ... [code omitted for brevity]
    }

    // ... [code omitted for brevity]
}
```

The `resolveClaim` function iterates over a potentially large number of challenge indices. If the subgame is very large, this loop could consume a significant amount of gas, potentially causing the transaction to run out of gas and fail.

### Impact

In cases where there are many challenges to resolve, the `resolveClaim` function may fail due to exceeding the block gas limit. This could prevent the resolution of large or complex dispute games, potentially leading to a denial of service for game resolution.

### Recommended Mitigation Steps

Consider implementing a pagination mechanism for resolving claims. This would allow resolving a fixed number of claims per transaction, preventing gas limit issues. For example:

```solidity
function resolveClaim(uint256 _claimIndex, uint256 _startIndex, uint256 _endIndex) external {
    // ... [existing code]

    uint256[] storage challengeIndices = subgames[_claimIndex];
    uint256 challengeIndicesLen = challengeIndices.length;

    require(_startIndex < challengeIndicesLen && _endIndex <= challengeIndicesLen, "Invalid indices");

    for (uint256 i = _startIndex; i < _endIndex; i++) {
        // ... [existing loop code]
    }

    // Update the checkpoint
    checkpoint.subgameIndex = uint32(_endIndex);

    // ... [remaining code]
}
```

This approach allows calling the function multiple times to resolve all claims in manageable chunks.

## QA-02 `getChallengerDuration` may return incorrect duration for games not in progress

### Proof of Concept
 
Location = [getChallengerDuration()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L767) 

```solidity
function getChallengerDuration(uint256 _claimIndex) public view returns (Duration duration_) {
    // INVARIANT: The game must be in progress to query the remaining time to respond to a given claim.
    if (status != GameStatus.IN_PROGRESS) {
        revert GameNotInProgress();
    }

    // Fetch the subgame root claim.
    ClaimData storage subgameRootClaim = claimData[_claimIndex];

    // Fetch the parent of the subgame root's clock, if it exists.
    Clock parentClock;
    if (subgameRootClaim.parentIndex != type(uint32).max) {
        parentClock = claimData[subgameRootClaim.parentIndex].clock;
    }

    // Compute the duration elapsed of the potential challenger's clock.
    uint64 challengeDuration =
        uint64(parentClock.duration().raw() + (block.timestamp - subgameRootClaim.clock.timestamp().raw()));
    duration_ = challengeDuration > MAX_CLOCK_DURATION.raw() ? MAX_CLOCK_DURATION : Duration.wrap(challengeDuration);
}
```

The `getChallengerDuration` function reverts if the game is not in progress. However, it might be useful to know the final duration even after the game has concluded.

### Impact

This limitation prevents querying the final challenger duration for completed games, which could be useful for analysis or auditing purposes.

### Recommended Mitigation Steps

Consider modifying the function to return the final duration even if the game is not in progress. This could be achieved by storing the final game timestamp when the game concludes:

```solidity
Timestamp public gameEndTimestamp;

function resolve() external returns (GameStatus status_) {
    // ... [existing code]
    
    gameEndTimestamp = Timestamp.wrap(uint64(block.timestamp));
    
    // ... [remaining code]
}

function getChallengerDuration(uint256 _claimIndex) public view returns (Duration duration_) {
    ClaimData storage subgameRootClaim = claimData[_claimIndex];
    Clock parentClock;
    if (subgameRootClaim.parentIndex != type(uint32).max) {
        parentClock = claimData[subgameRootClaim.parentIndex].clock;
    }

    uint64 endTimestamp = status == GameStatus.IN_PROGRESS ? uint64(block.timestamp) : gameEndTimestamp.raw();
    uint64 challengeDuration =
        uint64(parentClock.duration().raw() + (endTimestamp - subgameRootClaim.clock.timestamp().raw()));
    duration_ = challengeDuration > MAX_CLOCK_DURATION.raw() ? MAX_CLOCK_DURATION : Duration.wrap(challengeDuration);
}
```

This change allows querying the challenger duration at any time, even after the game has concluded.

## QA-03 `challengeRootL2Block` function does not verify the integrity of `_outputRootProof`

### Proof of Concept

Location = [challengeRootL2Block()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L492)

```solidity
function challengeRootL2Block(
    Types.OutputRootProof calldata _outputRootProof,
    bytes calldata _headerRLP
) external {
    // ... [code omitted for brevity]

    // Verify the output root preimage.
    if (Hashing.hashOutputRootProof(_outputRootProof) != rootClaim().raw()) revert InvalidOutputRootProof();

    // Verify the block hash preimage.
    if (keccak256(_headerRLP) != _outputRootProof.latestBlockhash) revert InvalidHeaderRLP();

    // ... [remaining code]
}
```

The `challengeRootL2Block` function verifies that the hash of the `_outputRootProof` matches the root claim, but it doesn't perform any integrity checks on the individual fields of the `_outputRootProof` struct.

### Impact

Without proper validation of the `_outputRootProof` fields, it may be possible to pass in malformed or inconsistent data that still produces a valid hash. This could potentially lead to incorrect challenge outcomes in the dispute game. The existing check `Hashing.hashOutputRootProof(_outputRootProof) != rootClaim().raw()` does provide some level of validation, however my suggested improvement checks will improve security.

### Recommended Mitigation Steps

Consider adding additional checks to validate the integrity of the `_outputRootProof` fields. For example:

```solidity
function challengeRootL2Block(
    Types.OutputRootProof calldata _outputRootProof,
    bytes calldata _headerRLP
) external {
    // ... [existing code]

    // Verify the output root preimage.
    if (Hashing.hashOutputRootProof(_outputRootProof) != rootClaim().raw()) revert InvalidOutputRootProof();

    // Additional integrity checks
    require(_outputRootProof.version == 0, "Invalid version");
    require(_outputRootProof.stateRoot != bytes32(0), "Invalid state root");
    require(_outputRootProof.messagePasserStorageRoot != bytes32(0), "Invalid message passer storage root");
    require(_outputRootProof.latestBlockhash != bytes32(0), "Invalid latest block hash");

    // Verify the block hash preimage.
    if (keccak256(_headerRLP) != _outputRootProof.latestBlockhash) revert InvalidHeaderRLP();

    // ... [remaining code]
}
```

These additional checks ensure that the critical fields of the `_outputRootProof` are not empty or set to invalid values.

## QA-04 Potential overflow in `getChallengerDuration` function

### Proof of Concept

Location = [getChallengerDuration()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L767)

```solidity
function getChallengerDuration(uint256 _claimIndex) public view returns (Duration duration_) {
    // INVARIANT: The game must be in progress to query the remaining time to respond to a given claim.
    if (status != GameStatus.IN_PROGRESS) {
        revert GameNotInProgress();
    }

    // Fetch the subgame root claim.
    ClaimData storage subgameRootClaim = claimData[_claimIndex];

    // Fetch the parent of the subgame root's clock, if it exists.
    Clock parentClock;
    if (subgameRootClaim.parentIndex != type(uint32).max) {
        parentClock = claimData[subgameRootClaim.parentIndex].clock;
    }

    // Compute the duration elapsed of the potential challenger's clock.
    uint64 challengeDuration =
        uint64(parentClock.duration().raw() + (block.timestamp - subgameRootClaim.clock.timestamp().raw()));
    duration_ = challengeDuration > MAX_CLOCK_DURATION.raw() ? MAX_CLOCK_DURATION : Duration.wrap(challengeDuration);
}
```

The function calculates the challenge duration by adding the parent clock's duration to the difference between the current timestamp and the subgame root claim's timestamp. However, this addition is performed before the overflow check, which could lead to an overflow if the sum exceeds `type(uint64).max`.

### Impact

In extreme cases where the game has been running for a very long time, this could lead to an incorrect duration calculation due to overflow, potentially affecting the game's timing mechanics.

### Recommended Mitigation Steps

Consider performing the overflow check before the addition, or use a safe math library for the addition. For example:

```solidity
uint64 parentDuration = parentClock.duration().raw();
uint64 elapsedTime = uint64(block.timestamp - subgameRootClaim.clock.timestamp().raw());
uint64 challengeDuration;
if (type(uint64).max - parentDuration < elapsedTime) {
    challengeDuration = type(uint64).max;
} else {
    challengeDuration = parentDuration + elapsedTime;
}
duration_ = challengeDuration > MAX_CLOCK_DURATION.raw() ? MAX_CLOCK_DURATION : Duration.wrap(challengeDuration);
```

## QA-05 `resolveClaim` function lacks check for zero `_numToResolve`

### Proof of Concept

Location = [resolveClaim()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L560) 

```solidity
function resolveClaim(uint256 _claimIndex, uint256 _numToResolve) external {
    // INVARIANT: Resolution cannot occur unless the game is currently in progress.
    if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();

    ClaimData storage subgameRootClaim = claimData[_claimIndex];
    Duration challengeClockDuration = getChallengerDuration(_claimIndex);

    // INVARIANT: Cannot resolve a subgame unless the clock of its would-be counter has expired
    // INVARIANT: Assuming ordered subgame resolution, challengeClockDuration is always >= MAX_CLOCK_DURATION if all
    // descendant subgames are resolved
    if (challengeClockDuration.raw() < MAX_CLOCK_DURATION.raw()) revert ClockNotExpired();

    // INVARIANT: Cannot resolve a subgame twice.
    if (resolvedSubgames[_claimIndex]) revert ClaimAlreadyResolved();

    uint256[] storage challengeIndices = subgames[_claimIndex];
    uint256 challengeIndicesLen = challengeIndices.length;

    // ... (rest of the function)
}
```

The `resolveClaim` function takes a `_numToResolve` parameter, but it doesn't check if this value is zero. If `_numToResolve` is zero, the function will still execute but won't resolve any claims, potentially wasting gas and allowing unnecessary function calls.

### Impact

This could lead to unnecessary gas consumption and potential confusion for users who might accidentally call the function with a zero value for `_numToResolve`.

### Recommended Mitigation Steps

Consider adding a check at the beginning of the function to revert if `_numToResolve` is zero:

```solidity
function resolveClaim(uint256 _claimIndex, uint256 _numToResolve) external {
    require(_numToResolve > 0, "Number to resolve must be greater than zero");
    // ... rest of the function
}
```

## QA-06 `challengeRootL2Block` function doesn't validate `_headerRLP` length

### Proof of Concept

Location = [challengeRootL2Block()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L492)

```solidity
function challengeRootL2Block(
    Types.OutputRootProof calldata _outputRootProof,
    bytes calldata _headerRLP
)
    external
{
    // ... (other checks)

    // Decode the header RLP to find the number of the block. In the consensus encoding, the timestamp
    // is the 9th element in the list that represents the block header.
    RLPReader.RLPItem[] memory headerContents = RLPReader.readList(RLPReader.toRLPItem(_headerRLP));
    bytes memory rawBlockNumber = RLPReader.readBytes(headerContents[HEADER_BLOCK_NUMBER_INDEX]);

    // Sanity check the block number string length.
    if (rawBlockNumber.length > 32) revert InvalidHeaderRLP();

    // ... (rest of the function)
}
```

The function decodes the RLP-encoded header but doesn't validate the length of `_headerRLP` before processing it. This could potentially lead to out-of-bounds access if the provided RLP data is malformed or shorter than expected.

### Impact

Malformed or too short RLP data could cause unexpected behavior, potentially leading to incorrect game state or reverts.

### Recommended Mitigation Steps

Add a check to ensure the `_headerRLP` has a minimum expected length before processing:

```solidity
function challengeRootL2Block(
    Types.OutputRootProof calldata _outputRootProof,
    bytes calldata _headerRLP
)
    external
{
    // ... (other checks)

    require(_headerRLP.length >= MINIMUM_HEADER_LENGTH, "Header RLP too short");

    // ... (rest of the function)
}
```

Replace `MINIMUM_HEADER_LENGTH` with the minimum expected length of a valid header RLP.

## QA-07 `claimCredit` function doesn't check if `_recipient` is a contract

### Proof of Concept

location = [claimCredit()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L747)

```solidity
function claimCredit(address _recipient) external {
    // Remove the credit from the recipient prior to performing the external call.
    uint256 recipientCredit = credit[_recipient];
    credit[_recipient] = 0;

    // Revert if the recipient has no credit to claim.
    if (recipientCredit == 0) revert NoCreditToClaim();

    // Try to withdraw the WETH amount so it can be used here.
    WETH.withdraw(_recipient, recipientCredit);

    // Transfer the credit to the recipient.
    (bool success,) = _recipient.call{ value: recipientCredit }(hex"");
    if (!success) revert BondTransferFailed();
}
```

The `claimCredit` function doesn't check if the `_recipient` is a contract. If it is, and it doesn't have a payable fallback or receive function, the transfer will fail, potentially locking the funds.

### Impact

This could lead to funds being permanently locked if the recipient is a contract without proper ETH receiving capabilities.

### Recommended Mitigation Steps

Consider adding a check to ensure the recipient is not a contract, or handle the case where it might be:

```solidity
function claimCredit(address _recipient) external {
    // ... (existing checks)

    if (_recipient.code.length > 0) {
        // If recipient is a contract, use a safe transfer method or revert
        IERC20(address(WETH)).safeTransfer(_recipient, recipientCredit);
    } else {
        // For EOA addresses, proceed with the existing logic
        (bool success,) = _recipient.call{ value: recipientCredit }(hex"");
        if (!success) revert BondTransferFailed();
    }
}
```

This modification ensures that contract recipients receive the funds via a safe ERC20 transfer, while EOA addresses receive ETH directly.

### **DisputeGameFactory** contract 

### QA-08 Lack of contract existence check in `setImplementation`

### Proof of Concept

In the `setImplementation` function, there's no check to ensure that the provided `_impl` address actually contains code:

- Location: [setImplementation()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L199)

```solidity
function setImplementation(GameType _gameType, IDisputeGame _impl) external onlyOwner {
    gameImpls[_gameType] = _impl;
    emit ImplementationSet(address(_impl), _gameType);
}
```

### Impact

If the owner accidentally sets an implementation to an address without code (e.g., an EOA or a not-yet-deployed contract), it could break the game creation process for that game type.

### Recommended Mitigation Steps

Add a check to ensure the implementation address contains code:

```solidity
function setImplementation(GameType _gameType, IDisputeGame _impl) external onlyOwner {
    require(address(_impl).code.length > 0, "Implementation must be a contract");
    gameImpls[_gameType] = _impl;
    emit ImplementationSet(address(_impl), _gameType);
}
```

## QA-09 Potential for creating duplicate games with different extraData

### Proof of Concept

The `create` function uses a hash of `_gameType`, `_rootClaim`, and `_extraData` to determine if a game already exists:

Location = [create()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L84)

```solidity
Hash uuid = getGameUUID(_gameType, _rootClaim, _extraData);
if (GameId.unwrap(_disputeGames[uuid]) != bytes32(0)) revert GameAlreadyExists(uuid);
```

However, this allows creating multiple games with the same `_gameType` and `_rootClaim` but different `_extraData`.

### Impact

This could lead to confusion and potential exploitation, as multiple games could exist for the same root claim, differentiated only by their extra data.

### Recommended Mitigation Steps

Consider using only `_gameType` and `_rootClaim` to determine uniqueness, or add additional checks to prevent creating multiple games for the same root claim:

```solidity
mapping(GameType => mapping(Claim => bool)) public gameExists;

function create(GameType _gameType, Claim _rootClaim, bytes calldata _extraData) external payable returns (IDisputeGame proxy_) {
    require(!gameExists[_gameType][_rootClaim], "Game already exists for this root claim");
    // ... existing creation logic ...
    gameExists[_gameType][_rootClaim] = true;
}
```

### **MIPS**

### QA-10 Lack of bounds checking in `SE` function

### Proof of Concept

The `SE` (Sign Extend) function doesn't check if the input `_idx` is within a valid range:

Location = [SE()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/MIPS.sol#L75)

```solidity
function SE(uint32 _dat, uint32 _idx) internal pure returns (uint32 out_) {
    unchecked {
        bool isSigned = (_dat >> (_idx - 1)) != 0;
        uint256 signed = ((1 << (32 - _idx)) - 1) << _idx;
        uint256 mask = (1 << _idx) - 1;
        return uint32(_dat & mask | (isSigned ? signed : 0));
    }
}
```

If `_idx` is 0 or greater than 32, it could lead to unexpected results.

### Impact

Incorrect sign extension could occur if the function is called with invalid parameters, potentially leading to misinterpretation of data in the MIPS emulation.

### Recommended Mitigation Steps

Add a bounds check to ensure `_idx` is within a valid range (1 to 32):

```solidity
require(_idx > 0 && _idx <= 32, "Invalid index for sign extension");
```

## QA-11 Potential overflow in `handleHiLo` function for `mult` and `multu` operations

### Proof of Concept

In the `handleHiLo` function, the `mult` and `multu` operations use 64-bit integers to store the result of multiplication:

Location = [handleHiLo()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/MIPS.sol#L383)

```solidity
else if (_func == 0x18) {
    uint64 acc = uint64(int64(int32(_rs)) * int64(int32(_rt)));
    state.hi = uint32(acc >> 32);
    state.lo = uint32(acc);
}
// multu: Unsigned multiplies `rs` by `rt` and stores the result in HI and LO registers
else if (_func == 0x19) {
    uint64 acc = uint64(uint64(_rs) * uint64(_rt));
    state.hi = uint32(acc >> 32);
    state.lo = uint32(acc);
}
```

While this approach works for most cases, it doesn't accurately represent the full range of possible MIPS multiplication results, which can be up to 128 bits wide.

### Impact

In edge cases involving very large numbers, the multiplication result might be truncated, leading to incorrect values stored in the `hi` and `lo` registers. This could potentially cause subtle errors in complex calculations within the MIPS emulation.

### Recommended Mitigation Steps

Consider using a 128-bit data type or a library that supports 128-bit arithmetic to ensure full precision for all possible MIPS multiplication results. For example:

```solidity
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

// ... 

else if (_func == 0x18) {
    int256 acc = int256(int32

(_rs)) * int256(int32(_rt));
    state.hi = uint32(uint256(acc) >> 32);
    state.lo = uint32(uint256(acc));
}
else if (_func == 0x19) {
    uint256 acc = uint256(_rs) * uint256(_rt);
    state.hi = uint32(acc >> 32);
    state.lo = uint32(acc);
}
```

This approach ensures that the full range of possible multiplication results is captured accurately.

### **PreimageOracle**

### QA-12 Potential for stale data in `loadBlobPreimagePart`
### Proof of Concept
- Location = [loadBlobPreimagePart()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageOracle.sol#L244) function:

```solidity
function loadBlobPreimagePart(
    uint256 _z,
    uint256 _y,
    bytes calldata _commitment,
    bytes calldata _proof,
    uint256 _partOffset
) external {
    // ... [code omitted for brevity]
    preimagePartOk[key][_partOffset] = true;
    preimageParts[key][_partOffset] = part;
    preimageLengths[key] = 32;
}
```

This function stores blob preimage parts without any timestamp or block number associated with them. 

### Impact
In the event of a blockchain reorganization or in systems where historical state is important, there's no way to determine when a specific blob preimage part was added or if it's the most recent version.

### Recommended Mitigation Steps
Consider adding a timestamp or block number when storing blob preimage parts:

```solidity
struct PreimagePart {
    bytes32 part;
    uint256 timestamp;
}

mapping(bytes32 => mapping(uint256 => PreimagePart)) public preimageParts;

function loadBlobPreimagePart(
    // ... [existing parameters]
) external {
    // ... [existing code]
    preimageParts[key][_partOffset] = PreimagePart(part, block.timestamp);
    // ... [remaining code]
}
```

### QA-13 Lack of cleanup mechanism for obsolete proposals
### Proof of Concept
- Location = Throughout the contract

The contract allows creation of large preimage proposals and stores significant data for each proposal, but there's no mechanism to clean up or remove old, resolved, or abandoned proposals.

### Impact
Over time, this could lead to accumulated storage bloat, potentially increasing gas costs for operations that interact with the proposal data structures. While not an immediate issue, it could affect long-term contract efficiency and state size.

### Recommended Mitigation Steps
Consider implementing a cleanup mechanism for proposals that have been finalized or have remained inactive for a long period. This could involve adding a function to remove old proposal data:

```solidity
function cleanupOldProposal(address _claimant, uint256 _uuid) external {
    LPPMetaData memory metaData = proposalMetadata[_claimant][_uuid];
    require(block.timestamp > metaData.timestamp() + CLEANUP_THRESHOLD, "Proposal not old enough");
    require(metaData.countered() || metaData.timestamp() == 0, "Cannot cleanup active proposals");
    
    delete proposalMetadata[_claimant][_uuid];
    delete proposalBranches[_claimant][_uuid];
    delete proposalBonds[_claimant][_uuid];
    delete proposalParts[_claimant][_uuid];
    delete proposalBlocks[_claimant][_uuid];
}
```

### **PreimageKeyLib**

### QA-14 Memory management in `keccak256PreimageKey`

### Proof of Concept

- Location = [keccak256PreimageKey()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageKeyLib.sol#L47)

```solidity
function keccak256PreimageKey(bytes memory _preimage) internal pure returns (bytes32 key_) {
    assembly {
        // Grab the size of the `_preimage`
        let size := mload(_preimage)

        // Compute the pre-image keccak256 hash (aka the pre-image key)
        let h := keccak256(add(_preimage, 0x20), size)

        // Mask out prefix byte, replace with type 2 byte
        key_ := or(and(h, not(shl(248, 0xFF))), shl(248, 2))
    }
}
```

The function doesn't explicitly clean up the memory it uses. While the EVM will handle this automatically, in some complex scenarios involving a lot of memory usage, this could potentially lead to higher gas costs.

### Impact

Higher gas costs in complex scenarios due to potential memory bloat.

### Recommended Mitigation Steps

Explicitly zero out the memory used for `_preimage` after computing the hash. This helps ensure no residual data remains in memory.

```solidity
function keccak256PreimageKey(bytes memory _preimage) internal pure returns (bytes32 key_) {
    assembly {
        // Grab the size of the `_preimage`
        let size := mload(_preimage)

        // Compute the pre-image keccak256 hash (aka the pre-image key)
        let h := keccak256(add(_preimage, 0x20), size)

        // Mask out prefix byte, replace with type 2 byte
        key_ := or(and(h, not(shl(248, 0xFF))), shl(248, 2))

        // Zero out the memory used for `_preimage`
        mstore(add(_preimage, 0x20), 0)
    }
}
```

### QA-15 Potential read-after-write hazard in `localize`

### Proof of Concept

- Location = [localize()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageKeyLib.sol#L29)

```solidity
function localize(bytes32 _key, bytes32 _localContext) internal view returns (bytes32 localizedKey_) {
    assembly {
        // Grab the current free memory pointer to restore later.
        let ptr := mload(0x40)
        // Store the local data key and caller next to each other in memory for hashing.
        mstore(0, _key)
        mstore(0x20, caller())
        mstore(0x40, _localContext)
        // Localize the key with the above `localize` operation.
        localizedKey_ := or(and(keccak256(0, 0x60), not(shl(248, 0xFF))), shl(248, 1))
        // Restore the free memory pointer.
        mstore(0x40, ptr)
    }
}
```

In the assembly block of `localize`, the free memory pointer is read, used, and then restored. If another operation were to modify memory between these operations (unlikely in this context, but possible in more complex scenarios), it could potentially lead to issues.

### Impact

Potential memory corruption if memory is modified between the operations.

### Recommended Mitigation Steps

Use a more secure method to handle memory operations, ensuring no unintended modifications occur.

```solidity
function localize(bytes32 _key, bytes32 _localContext) internal view returns (bytes32 localizedKey_) {
    assembly {
        // Grab the current free memory pointer to restore later.
        let ptr := mload(0x40)
        // Use a secure temporary memory location to avoid corruption.
        let temp := add(ptr, 0x60)
        // Store the local data key and caller next to each other in memory for hashing.
        mstore(temp, _key)
        mstore(add(temp, 0x20), caller())
        mstore(add(temp, 0x40), _localContext)
        // Localize the key with the above `localize` operation.
        localizedKey_ := or(and(keccak256(temp, 0x60), not(shl(248, 0xFF))), shl(248, 1))
        // Restore the free memory pointer.
        mstore(0x40, ptr)
    }
}
```

### QA-16 Lack of zero-length input handling in `keccak256PreimageKey`

### Proof of Concept

- Location = [keccak256PreimageKey()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/PreimageKeyLib.sol#L47) 

```solidity
function keccak256PreimageKey(bytes memory _preimage) internal pure returns (bytes32 key_) {
    assembly {
        // Grab the size of the `_preimage`
        let size := mload(_preimage)

        // Compute the pre-image keccak256 hash (aka the pre-image key)
        let h := keccak256(add(_preimage, 0x20), size)

        // Mask out prefix byte, replace with type 2 byte
        key_ := or(and(h, not(shl(248, 0xFF))), shl(248, 2))
    }
}
```

If an empty byte array is passed to this function, it will still compute a key. This may or may not be the intended behavior, depending on the broader context of how this function is used.

### Impact

Potential unexpected behavior or security vulnerabilities if empty byte arrays are not intended to be handled.

### Recommended Mitigation Steps

Add a check to handle zero-length inputs appropriately, either by reverting or by returning a specific value.

```solidity
function keccak256PreimageKey(bytes memory _preimage) internal pure returns (bytes32 key_) {
    require(_preimage.length > 0, "Empty preimage not allowed");
    assembly {
        // Grab the size of the `_preimage`
        let size := mload(_preimage)

        // Compute the pre-image keccak256 hash (aka the pre-image key)
        let h := keccak256(add(_preimage, 0x20), size)

        // Mask out prefix byte, replace with type 2 byte
        key_ := or(and(h, not(shl(248, 0xFF))), shl(248, 2))
    }
}
```

### **LPPMetadataLib**

### QA-17 Inconsistent data type for `partOffset` function return type

### Proof of Concept

- Location: [partOffset()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L66)

```solidity
function partOffset(LPPMetaData _self) internal pure returns (uint64 partOffset_) {
    assembly {
        partOffset_ := and(shr(160, _self), U32_MASK)
    }
}
```

The `partOffset` function returns a `uint64`, but the `setPartOffset` function sets a `uint32` value. This inconsistency could lead to confusion and potential errors in data handling.

### Impact

Potential for inconsistency in data handling.

### Recommended Mitigation Steps

Change the return type of `partOffset` to `uint32`.

```solidity
function partOffset(LPPMetaData _self) internal pure returns (uint32 partOffset_) {
    assembly {
        partOffset_ := and(shr(160, _self), U32_MASK)
    }
}
```

### QA-18 Potential data truncation in `setCountered` function

### Proof of Concept

- Location = [setCountered()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L54)

```solidity
function setCountered(LPPMetaData _self, bool _countered) internal pure returns (LPPMetaData self_) {
    assembly {
        self_ := or(_countered, and(_self, not(U64_MASK)))
    }
}
```

The `setCountered` function sets the `countered` bit but may inadvertently affect other metadata fields if `_countered` is set to true, potentially causing data truncation.

### Impact

Potential corruption of metadata fields.

### Recommended Mitigation Steps

Ensure `_countered` only affects the intended bit and does not alter other metadata fields.

```solidity
function setCountered(LPPMetaData _self, bool _countered) internal pure returns (LPPMetaData self_) {
    assembly {
        self_ := or(shl(0, _countered), and(_self, not(U64_MASK)))
    }
}
```

### QA-19 Lack of bounds checking in `set` functions

### Proof of Concept

- Location = [setTimestamp()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L24), [setPartOffset()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L30), [setClaimedSize()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L36), [setBlocksProcessed()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L42), [setBytesProcessed()](https://github.com/code-423n4/2024-07-optimism/blob/main/packages/contracts-bedrock/src/cannon/libraries/CannonTypes.sol#L48) 

```solidity
function setTimestamp(LPPMetaData _self, uint64 _timestamp) internal pure returns (LPPMetaData self_) {
    assembly {
        self_ := or(shl(192, _timestamp), and(_self, not(shl(192, U64_MASK))))
    }
}

// Similar lack of bounds checking in other `set` functions.
```

The `set` functions do not check the bounds of their inputs, potentially leading to incorrect metadata values if inputs are outside expected ranges.

### Impact

Incorrect metadata values due to lack of input validation.

### Recommended Mitigation Steps

Add bounds checking for inputs in `set` functions to ensure they are within expected ranges.

```solidity
function setTimestamp(LPPMetaData _self, uint64 _timestamp) internal pure returns (LPPMetaData self_) {
    require(_timestamp <= type(uint64).max, "Timestamp out of bounds");
    assembly {
        self_ := or(shl(192, _timestamp), and(_self, not(shl(192, U64_MASK))))
    }
}

// Add similar bounds checks for other `set` functions.
```